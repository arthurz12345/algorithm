import java.util.*;

// this version compute the total optimal weight
public class WgtIntSchedulerV1 {
 
    // A job object has id, start time, finish time and weight.
    static class Job {
        int id, start, finish, weight;
        Job(int id, int s, int f, int w)
        {
            this.id = id;
            this.start = s;
            this.finish = f;
            this.weight = w;
        }
    }
 
    // Find the latest job (in sorted array) that doesn't
    // conflict with the job[i]. If there is no compatible
    // job, then it returns -1.
    static int latestNonConflict(Job arr[], int i)
    {
        for (int j = i - 1; j >= 0; j--) {
            // finish before next is started
            if (arr[j].finish <= arr[i - 1].start){
                System.out.println("latestNonConflict for " + i + ": " + j);
                return j;
            }
        }
        return -1;
    }
 
    static int findMaxWeightDP(Job arr[])
    {
        int n = arr.length;
        // Create an array to store solutions of
        // subproblems.  table[i] stores the weight for jobs
        // till arr[i] (including arr[i])
        int[] table = new int[n];
        table[0] = arr[0].weight;
 
        // Fill entries in M[] using recursive property
        for (int i = 1; i < n; i++) {
            // Find weight including the current job
            int inclProf = arr[i].weight;
            int l = latestNonConflict(arr, i);
            if (l != -1)
                inclProf += table[l];
 
            // Store maximum of including and excluding
            table[i] = Math.max(inclProf, table[i - 1]);
        }
        System.out.print("table:");
        System.out.println(Arrays.toString(table));
        
        // Store result and free dynamic memory allocated
        // for table[]
        int result = table[n - 1];
 
        return result;
    }
 
    
    public static int[] getOptSet (int[] stime, int[] ftime, int[] weight)
    {
        return null;
    }
    
    public static int getOptWeight(int[] stime, int[] ftime, int[] weight)
    {
        Job jobs[] = sortJobs(stime, ftime, weight);
        return findMaxWeightDP(jobs);
    }
    
    static Job[] sortJobs(int[] s, int[] f, int[] w)
    {
        int n = w.length; // total number of jobs
        
        // Create object structure so that we can keep track of job id
        Job jobs[] = new Job[n];
        for (int i = 0; i < n; i++)
        {
            jobs[i] = new Job(i + 1, s[i], f[i], w[i]);
        }
        
        System.out.println("jobs:");
        for(Job j: jobs){
            System.out.println("job" + j.id + ":" + j.start + "-" + j.finish + "-" + j.weight);
        }
        
        // Sort jobs by finish time ascending
        Arrays.sort(jobs, new Comparator<Job>() {
            public int compare(Job job1, Job job2)
            {
                return job1.finish - job2.finish;
            }
        });
        
        System.out.println("jobs:");
        for(Job j: jobs){
            System.out.println("job" + j.id + ":" + j.start + "-" + j.finish + "-" + j.weight);
        }
        
        return jobs;
    }
    
    // main program
    public static void main(String args[])
    {
        int s[] = {4, 3, 2, 10, 7}; // start times for jobs 1, 2, 3, 4, 5
        int f[] = {7, 10, 6, 13, 9}; // finish times for jobs 1, 2, 3, 4, 5
        int w[] = {6, 6, 5, 2, 8}; // weights for jobs 1, 2, 3, 4, 5
        
        System.out.println("The optimal weight is "+ getOptWeight(s, f, w));
    }

}
